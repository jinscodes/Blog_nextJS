**1️⃣ REST란?**

REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다. 구체적으로, REST는 자원 기반 구조(ROA, Resource Oriented Architecture)가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미합니다. 또한, REST는 HTTP URI를 통해 자원을 명시하고, HTTP Method를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다. 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일입니다. REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나입니다.

웹사이트의 이미지, 텍스트, DB 내용 등 모든 자원에 대한 고유한 ID인 HTTP URI가 부여됩니다.

> 💡 여기서 CRUD란 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말입니다. REST에서의 CRUD Operation 동작은 아래와 같습니다.

상태 또는 정보 전달과 관련하여 데이터가 요청 되어지는 시점에서 자원의 상태 또는 정보를 전달합니다. 이때, 자원의 형태는 주로 JSON이나 XML형태의 데이터를 주고 받는 것이 일반적입니다. 월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식입니다.

**2️⃣ REST의 구성요소**

REST는 크게 3가지로 구성되어있습니다: 자원, 자원에 대한 행위, 자원에 대한 행위의 내용. 자원은 HTTP의 URI에 해당합니다. 자원에 대한 행위는 HTTP Method에 해당합니다. 자원에 대한 행위의 내용은 HTTP Message Pay Load에 해당합니다.

자원(Resource): URI

- 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재합니다.
- HTTP URI로 자원을 구별합니다.
- Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청합니다.

행위(Verb): HTTP Method

- HTTP 프로토콜의 Method를 사용합니다
- HTTP 프로토콜은 GET, POST, PUT, DELETE와 같은 메서드를 제공합니다

표현(Representation of Resource)

- Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답을 보냅니다.
- REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태로 표현될 수 있습니다.
- 보통, JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적입니다.

**3️⃣ REST 특징**

##### Server-Client 구조

REST는 Server-Client 구조를 가지고 있습니다. 클라이언트가 HTTP 메세지를 통해서 서버에 요청을 보내고 서버의 응답이 올 때까지 기다립니다. 그 후, 서버가 요청에 대한 결과를 응답하면, 클라이언트가 그 결과를 받아서 동작합니다.

단순한 과정이지만, 이 과정을 통해 서버와 클라이언트를 분리할 수 있다는 장점이 있습니다. 서버와 클라이언트의 분리를 통해, 비즈니스 로직과 데이터는 서버에, UI와 UX를 고려하는 것은 클라이언트에 분배할 수 있습니다.

> 💡 결론적으로, Server-Client 구조를 통해, 서버와 클라이언트가 독립적으로 진화할 수 있습니다.

##### 무상태 프로토콜

HTTP는 무상태 프로토콜을 지향합니다. 무상태는 서버와 클라이언트가 서로의 상태를 보존하지 않는다는 의미입니다. HTTP는 무상태를 지향하기 때문에, 필요한 데이터를 그때 그때 넘겨주어야 합니다.

HTTP의 무상태 프로토콜 특성 덕분에, Server-Client 아키텍쳐에 엄청난 확장성을 가져옵니다. 왜냐하면, 상태를 유지하면 서버는 클라이언트 요청에 따른 정보를 서버에 항상 유지해야합니다. 이렇게 되면, 클라이언트 요청을 받고 상태를 저장하고 있는 서버와 클라이언트의 연결이 항상 유지되어야합니다. 즉, 서버를 늘리기가 어렵게 됩니다. 또한, 중간에 문제가 발생하여 서버가 가지고 있던 상태를 잃어버리게 되면, 처음부터 다시 통신해야합니다.

무상태의 경우, 서버는 상태를 보관하지 않고 응답만 해주면 됩니다. 이 말은 즉, 서버와 클라이언트의 연결이 항상 유지될 필요가 없기 때문에 서버의 확장성이 보장됩니다. 또한, 중간에 문제가 발생해도 잃어버릴 상태가 없기 때문에 아무런 문제가 되지 않습니다.

이와 같이 무상태에서는 서버를 수평적으로 확장할 수 있는 scale-out이 가능합니다.

![stateless-scaleout](https://github.com/user-attachments/assets/3ce4839b-dd07-48d1-9368-84790af78395)

물론, 무조건적으로 무상태를 사용하는 것은 아닙니다. 로그인이 필요 없는 간단한 소개페이지의 경우에는 상태를 유지할 필요가 없기 때문에 무상태로 개발하면 되지만, 유저의 정보를(상태)를 저장해야만하는 페이지의 경우에는 상태를 유지해야 합니다.

##### 비연결성

TCP/IP는 기본적으로 연결을 유지합니다. 즉, 서버의 자원을 계속 소모합니다. 비연결성의 경우 서버와 클라이언트의 연결을 유지하지 않습니다. 연결을 유지하지 않는 모델의 경우, 클라이언트의 요청 시 서버는 응답하고 그 응답을 받으면 즉시 연결이 끊기게 됩니다. 이렇게 되면, 요청을 주고 받을 때만 연결을 하고 이후에는 연결이 끊기기 때문에 서버가 소모하는 자원이 최소한이 됩니다.

비연결성은 크게 두가지 단점을 가지고 있는데, 첫번째는 시간이 상대적으로 오래 걸립니다. 서버와 클라이언트가 소통할때마나 TCP/IP 연결을 매번 새로 해야하기 때문입니다. 3 way handshake 기번을 사용하기 때문에 상대적으로 시간이 오래 걸립니다. 두번째로 웹 브라우저로 사이트를 요청하면 HTML, css, JS, 이미지 등 수많은 자원들이 매번 다운로드 됩니다. 현재는 HTTP에서 기본적으로 사용하고 있는 지속연결(Persistent Connection)로 문제를 해결하고 있습니다.

![persistence-connection](https://github.com/user-attachments/assets/404f1e18-2e09-42af-aac2-e2f74853c1df)

---

[](https://xxsxkz.tistory.com/entry/HTTP-2)

[](https://velog.io/@alwaysryu13/REST-%ED%86%B5%EC%8B%A0%EC%9D%B4%EB%9E%80-Java%EB%A1%9C-REST%ED%86%B5%EC%8B%A0%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0)

[](https://www.ibm.com/kr-ko/topics/rest-apis)

[](https://khj93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-REST-API%EB%9E%80-REST-RESTful%EC%9D%B4%EB%9E%80)
