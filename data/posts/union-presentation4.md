JavaScript는 고수준의 동적으로 입력되는 클라이언트 측 스크립팅 언어입니다. 정적 HTML 페이지에 기능을 추가합니다. 대부분의 다른 프로그래밍 언어와 마찬가지로 JavaScript는 딥 카피와 얕은 카피의 개념을 지원합니다.

모든 데이터 타입은 값 타입(value type) 또는 참조 타입(reference type)을 가진다.

**1️⃣ 얕은 복사**

얕은 복사란 무엇인가?

![얕은복사예시1](https://github.com/user-attachments/assets/6859b50b-7f0a-4b31-9c74-7428a444480e)

위 코드와 같이, `{a: 1, b: 2}` 라는 객체를 obj1과 obj2라는 변수에 직접 대입하는 경우에는 **참조에 의한 할당**이 이루어지게 됩니다. 참조에 의한 할당이 이루어지게 되면 둘은 같은 데이터 주소를 갖게 됩니다. 따라서 원본이나 복사본을 변경하면, 다른 객체 또한 변경될 수 있습니다.

- 두 객체(obj1, obj2)는 같은 객체가 아니다
- obj1과 obj2의 속성은 같은 이름과 순서
- 두 객체의 속성 값은 동일
- 두 객체의 프로토타입 체인은 동일

✣ 참조에 의한 할당이라는 말은 원본 객체와 복사본과 같은 참조를 공유하는 것을 말합니다.

![얕은 복사-주소 복사](https://github.com/user-attachments/assets/0b89cbb3-31a3-4dfa-96e8-03f64a2315d0)

그림에서 확인할 수 있는 것처럼 원시형 데이터는 스택 메모리만을 이용하고, 메모리에 값 자체를 저장합니다. 그래서 원본(num1)을 새로운 변수(num2)에 할당하면 값을 복사하기에 완전히 새로운 값이 만들어 집니다. 다만 비교 연산자는 123이라는 값 자체만 두고 비교하기 때문에, true라는 결과를 얻게 되는 것이지요.

반면 참조형 데이터는 스택 외에도 힙이라 하는 메모리를 사용하며, 이를 스택에서 참조하는 방식으로 동작합니다. 그렇기 때문에 스택에는 힙을 가리키는 주소를 담게 되고, 원본(obj1)을 새로운 변수(obj2)에 복사하게 되면 스택에 담긴 메모리 주소를 복사하게 됩니다. 그래서 두 변수는 동일한 하나의 객체를 가리키게 되고, obj2를 수정했음에도 obj1을 수정한 것과 같게 됩니다. 참조형 데이터의 특성으로 인해 메모리가 복사되는 것을 얕은 복사라 부릅니다.

원시형 데이터는 기본적으로 깊은 복사가, 참조형 데이터는 얕은 복사가 발생합니다.

> JavaScript에서, 모든 표준 내장 객체의 복사 작업  
> `전개 구문`, `Array.prototype.concat()`, `Array.prototype.slice()`, `Array.from()`, `Object.assign()`, `Object.create()`  
> 은 깊은 복사가 아닌 얕은 복사본을 생성합니다.

**2️⃣ 깊은 복사**

원시형 데이터와 달리 참조형 데이터는 얕은 복사가 일어나기 때문에, 따로 처리를 해주어야 합니다.

##### 반복문을 이용한 방법

![깊은복사-반복문예시](https://github.com/user-attachments/assets/7e2b9550-caa2-439a-ba25-b47dda124792)

반복문을 이용해서 깊은 복사를 하는 방법이 있습니다. 우선, 새로운 변수에 빈 배열과 빈 객체를 할당합니다. 그 후, 반복문을 통해 복사하고자 하는 데이터의 값을 하나씩 복사하면 됩니다. 이렇게 하면 같은 값을 가지지만 서로 다른 변수가 됩니다.

##### 전개 연산자를 이용한 방법

![깊은복사-전개연산자](https://github.com/user-attachments/assets/dac5d1cb-a759-4c6d-8ea9-f7a40becd9f5)

전개 연산자(Spread Operator)는 반복 가능한 요소를 전개하여 배열 또는 객체를 만드는 것을 말합니다. 즉, 반복 가능한 요소인 문자열, 배열, 객체 등의 내부 값들을 전개하여 새로운 데이터를 만듭니다. 새로운 데이터를 만들기 때문에 깊은 복사가 가능합니다. 또한, 반복문을 이용한 방법보다 짧은 코드로 구현이 가능하다는 장점이 있습니다.

**3️⃣ 완벽한 깊은 복사**

위에서 소개한 두가지 깊은 복사 방법은 완벽하게 깊은 복사를 수행하지 못합니다. 왜냐하면 최상위 블로에 대해서만 깊은 복사가 가능하고 내부의 참조형 데이터들은 여전히 얕은 복사가 되기 때문입니다. 예를 들어,

![미완벽-깊은복사](https://github.com/user-attachments/assets/fe1a3d6f-3105-4b1d-a783-7cbd86f30836)

위와 같은 코드가 있을 때, arr1과 arr2는 깊은 복사가 되었지만, 그 안에 있는 요소인 obj1에 대해서는 여전히 앝은 복사를 합니다. 즉, 완벽한 깊은 복사가 되지 않습니다. 이를 해결하기 위해 몇가지 방법이 있습니다.

##### 재귀 함수를 통한 깊은 복사

![깊은복사-재귀함수](https://github.com/user-attachments/assets/8a905438-1974-4c3d-98e7-8e4e5aa3b764)

내부가 객체인 경우 콘텐츠의 반복적인 복사를 통해 완벽한 깊은 복사를 진행할 수 있습니다. 단점은 심부 방사선 조사가 재귀 함수를 통해 수행되면 복잡해진다는 것입니다.

> 💡 재귀함수란?  
> 함수 안에 자신의 함수를 다시 호출하는 함수를 의미합니다. 이러한 재귀함수는 자신의 로직을 내부적으로 반복하다가, 일정한 조건이 만족되면 함수를 이탈하여 결과를 도출합니다.

##### JSON.parse && JSON.stringify를 통한 깊은 복사

![깊은복사-JSON](https://github.com/user-attachments/assets/93ab6241-8607-4dd3-9590-99264b89a87d)

JSON.stringify()객체를 JSON 문자열로 변환하는데, 이는 원래 객체에 대한 모든 참조를 끊습니다. 객체를 JSON 문자열로 변환한 후, JSON.parse()다시 원래 객체(Java 스크립트 객체)로 만드는 데 사용합니다. 이 방법은 가장 간단하고 쉽지만, 다른 방법에 비해 느리며, 객체가 함수일 경우 정의되지 않은 것으로 처리됩니다.

##### Lodash 라이브러리를 통한 깊은 복사

![깊은복사-라이브러리](https://github.com/user-attachments/assets/8d3b2255-4cb8-474b-b082-c5ab137decca)

라이브러리를 이용하면 심층적 복사가 더 쉽고 안전해집니다. 단점은 설치가 필요하고 일반적인 개발에는 효율적이지만, 코딩 테스트에는 사용할 수 없다는 점입니다.
